\section{Targeted} \label{sec:targeted}
    Even after eleminating cache effects, a fundamental challenge in memory access remains: the 
    fixed mapping between physical addresses and the underlying \gls{dram} layout. It is insufficient 
    to merely perform \gls{dram} accesses. Rather, precise access to specific \gls{dram} rows is required to
    induce bit flips in adjacent victim rows, denoted as P2. Targeted. The physical address is 
    composed of bits that are partitioned into rank, channel, bank, row, and column, which 
    collectively determine the location where the data is stored [94].
    However, the details of this mapping are not publicly disclosed. Knowledge of the \gls{dram} 
    address mapping enables a wide range of applications, including application-aware memory 
    channel partitioning, adapted page sizes for improved row buffer utilization, efficient use 
    of emerging hybrid memory technologies, evaluation of the effects of unreliable memory, and 
    \gls{dram} layout-aware memory allocators [94].

    \subsection{Reverse Engineering} \label{subsec:reverse-engineering}
        When the \gls{dram} mapping is known, memory systems become more susceptible to attacks, leading 
        to higher pressure and an increased likelihood of bit flips. The addressing scheme can vary 
        for each system, as it depends on multiple factors such as the processor model, DIMM 
        population on the motherboard, and BIOS settings, according to [94]. Therefore, 
        it is necessary to reverse-engineer the \gls{dram} address mapping for all test devices. This 
        process leverages the fact that \gls{dram} consistently follows a hierarchical organization, as 
        described in the \hyperref[sec:background]{Background} section of this thesis. As a consequence of this 
        structure, memory access latencies vary depending on the physical location of data within 
        the hardware [159].

        \subsubsection{Methods} \label{subsubsec:methods}
            \textbf{PALLOC}, introduced by Yun et al. [75] in 2014, uses a dedicated microbenchmark 
            that traverses a linked list over the physical address space to enforce constant \gls{dram} 
            access while controlling bank usage.
            \\
            \textbf{DRAMA}, proposed by Pessl et al. [73] in 2016, exploits the row-buffer timing side 
            channel, where row conflicts cause increased memory access latency. This approach 
            enables the construction of address sets that share channel, rank, and bank 
            properties by performing exhaustive testing of linear addressing functions with an 
            increasing number of coefficients.
            \\
            \textbf{Reliable RE}, presented by Helm et al. [94] in 2020, extends DRAMA by integrating 
            performance counters, which identifies row hits and misses more reliable 
            during the reverse-engineering process.
            \\
            \textbf{DRAMDig}, introduced by Wang et al. [76] in 2020, builds upon DRAMA by incorporating 
            detailed knowledge of specific \gls{dram} chip geometries and processor microarchitecture, thereby 
            reducing the search space of the exponential-time. This method is employed, for example, by 
            the DRAM MaUT tool [79].
            \\
            \textbf{One Bitflip One Cloud Flop}, described by Xiao et al. [93] in 2016, proposes a graph-based 
            approach to infer physical-to-DRAM mappings. It relies on timing differences caused by 
            row conflicts and, similar to DRAMA, primarily aimed at enabling Rowhammer attacks 
            across virtual machines.
            \\
            Common characteristics of DRAMA-based methods include the clustering of addresses into 
            sets that experience row conflicts or row hits, indicating placement within the same bank. 
            These sets are derived by determining which combinations of address bits identify them, 
            often expressed as linear XOR combinations. This approach underlies several attacks 
            and tools, including [38, 53, 72].
            \\
            \textbf{Knock-Knock}, introduced by Plin et al. [99] 2025, reformulates the identification of 
            \gls{dram} parity masks as a linear algebra problem. Instead of relying on exhaustive search, it 
            focuses on solving the mapping directly through algebraic reasoning.

        \subsubsection{Graph-based Approach} \label{subsubsec:graph-based-approach}
            This is a test.
        
        \subsubsection{DRAMA Approach} \label{subsubsec:drama-approach}
            This is a test.

    \subsection{Verification} \label{subsec:verification}
        For each test device, a \gls{dram} address mapping has been derived. However, the completeness and 
        correctness of the recovered mappings cannot be guaranteed. To assess the validity of the inferred 
        \gls{dram} addressing functions, several verification approaches can be employed.
        \\
        % Physical Probing
        One method involves comparing the inferred functions against results obtained via \textbf{physical probing}, 
        as reported in prior work [73]. In general, embedded systems are characterized by small chips and 
        multi-layered circuit boards [159]. On Raspberry Pi devices, direct hardware-level verification is 
        not feasible, as the \gls{dram} is soldered to the board and therefore inaccessible.
        \\
        % Rowhammer
        Another verification approach is to use \textbf{Rowhammer} experiments to validate the addressing functions. 
        If the inferred functions are correct, their application should increase the bit flip rate 
        proportionally to the number of identified sets [73]. However, this method is often impractical due 
        to potentially long execution times, the presence of mitigation mechanisms, or limited susceptibility 
        of the system to Rowhammer. Even on systems previously identified as vulnerable, the distribution 
        and occurrence of vulnerable memory regions vary across \gls{dram} chips, and not every device of the 
        same model exhibits Rowhammer bit flips [Drammer, 72].
        \\
        % Software-based Verification
        A purely \textbf{software-based} evaluation constitutes an alternative approach, which verifies timing 
        differences across a larger set of addresses [73]. This method is feasible and allows validation 
        without hardware access.
        \\
        The verification can be performed using the DRAMA methodology [73, 116]. In this approach, memory 
        access latencies are measured and histograms are constructed to distinguish row hits from row 
        conflicts. Address pairs predicted to map to the same \gls{dram} bank and row, denoted as row hits, or to the same 
        bank but different rows, indicates as row conflicts, are identified. Access times are measured after flushing 
        the relevant cache lines to minimize caching effects. Timing histograms are then used to calibrate 
        a threshold separating row hits from row conflicts. The \gls{dram} mapping is validated by comparing the 
        measured latencies with the predicted relationships, as described in the \hyperref[subsubsec:drama-approach]{previous section}.
        \\
        The verification assumes that addresses classified as same set and same row indeed result in row 
        hits, and that addresses classified as same set and different row produce row conflicts. If the 
        mapping is correct, two clearly separable timing distributions are expected. The hit histogram 
        should show a dominant peak at low \gls{cpu} cycle counts, while the miss histogram should exhibit a dominant 
        peak at significantly higher \gls{cpu} cycle counts. Minimal overlap between hit and conflict histograms is 
        anticipated, and a stable, clear timing gap should exist. This scenario is recognizable when the 
        printed histograms display a bimodal pattern, rows labeled as hits are consistently faster than 
        conflicts, and repeated measurements produce similar histograms and thresholds.
        \\
        Verification of the \gls{dram} mapping was conducted on multiple Raspberry Pi devices using averages of 
        several measurements. On Raspberry Pi 4 devices, with the \gls{dram} mapping \texttt{6, 12, 13, 14}, hammerpi 
        produced distinct peaks corresponding to row hits and row conflicts, although the observed \gls{cpu} 
        cycles were relatively low. This pattern was consistent across repeated measurements, confirming 
        the presence of measurable row hit and row conflict peaks. In contrast, Raspberry Pi 5 devices, 
        with the \gls{dram} mapping \texttt{6, 12}, did not yield valid results, as no reliable peaks 
        could be observed. Consequently, while the \gls{dram} mapping could be validated on Raspberry Pi 4 
        devices, the verification failed on Raspberry Pi 5 devices, and the underlying cause of this 
        discrepancy remains unclear.
        \begin{figure}[htbp]
            \centering
            \frame{\includegraphics[width=\linewidth]{img/calibration.pdf}}
            \caption{Timing Histogram of Raspberry Pi 4 mapping}
            \label{fig:calibrate}
        \end{figure}
