%% MAKE BETTER
    %% Check "Non-temporal accesses"
    %% Check "Uncached memory"
    %% Add Abbreviations
    %% Formatierung


\section{Uncached} \label{sec:uncached}
    To achieve~\hyperref[prim:uncached]{P1. Uncached}, the cache must be completely bypassed so that all memory accesses repeatedly 
    reach the DRAM without being served from any cache level. This section therefore provides a brief 
    discussion of the available methods to bypass CPU caches, explains why certain approaches are selected 
    or discarded, and identifies the most effective method on ARM-based systems such as the Raspberry Pi. 
    In addition, it outlines the general implementation process, including the main development steps and 
    the challenges encountered during implementation.
    \\
    From a high-level perspective, several methods are considered and evaluated as potential approaches to 
    achieve uncached memory accesses. These methods include non-temporal accesses, explicitly uncached 
    memory, cache eviction, and cache flushing. Each approach differs in its feasibility, effectiveness, 
    and platform dependency, particularly on ARM-based architectures.

    \subsection{Non-temporal accesses} \label{subsec:non-temporal-accesses}
        Non-temporal accesses have been proposed as a cache-bypassing technique in the context of Rowhammer 
        attacks. In particular, [105] introduce a Rowhammer approach based on x86 non-temporal instructions. 
        Non-temporal data refers to data that is accessed once and not reused in the near future, exhibiting 
        low temporal locality, such as streaming data, which ideally should not be cached in order to avoid 
        cache pollution [~Triggering RH]. This cache-bypassing capability significantly facilitates Rowhammer 
        attacks on x86 architectures, as demonstrated in [105]. However, as discussed in [~Drammer], ARMv8-A 
        non-temporal memory access instructions merely provide a hint to the memory system that caching is 
        not required, and in practice the accessed data is still cached. Although the ARMv8-A instruction set 
        includes non-temporal load and store instructions, such as LDNP and STNP, it is generally considered 
        that these instructions are not effective for triggering the RH bug [Quote of ~Triggering RH]. This 
        observation is further reinforced by the statement in [~Drammer] that these ARMv8-A non-temporal memory 
        access instructions do not reliably bypass the cache and that data accessed through them is still found 
        cached in practice [Quote of Triggering RH]. Conceptually, non-temporal operations do not follow 
        standard cache-coherency rules and are assumed by the memory controller to access data that will not 
        be reused, and several non-temporal instructions are designed to bypass the cache. Nevertheless, a 
        major limitation of this approach is that all non-temporal stores to a single address are combined 
        into a single write-combining (WC) buffer, such that only the last write is eventually forwarded to 
        DRAM, regardless of how many stores are issued. As a result, the effective access rate is insufficient 
        to perform reliable hammering [58]. Since Rowhammer requires a very high access rate, this limitation 
        makes non-temporal accesses unsuitable for this purpose [lecture-introduction].
    
    \subsection{Uncached memory} \label{subsec:uncached-memory}
        Another approach is the use of explicitly uncached memory. This method allocates memory regions that 
        are explicitly marked as uncached, for example via ION, such that every memory access goes directly 
        to DRAM without interacting with the CPU cache. This approach is particularly well suited for mobile 
        ARM platforms, such as ARMv7 and ARMv8 systems, where cache flush instructions are sometimes privileged, 
        cache eviction is often too slow, and non-temporal stores are still cached in practice [58]. An 
        important advantage of this method is that it does not require special privileges or permissions. 
        Previous work takes advantage of DMA buffers exposed to userspace through the Android ION memory 
        management interface [~Drammer]. However, [~GuardION] has rendered Rowhammer attacks triggered in this 
        way non-exploitable. More generally, leveraging user-accessible DMA buffers on Android systems to 
        bypass CPU caches has been explored in [38] [Quote of Triggering RH]. Despite its effectiveness on 
        Android, this technique suffers from platform-specific memory management limitations. The Android 
        ION memory management framework is tightly coupled to the Android kernel and userspace stack and is 
        not available on standard Raspberry Pi Linux distributions. Consequently, user-accessible DMA buffers 
        provided by ION cannot be allocated or controlled on a Raspberry Pi, rendering this cache-bypass 
        technique inapplicable in that environment.
        \\
        In the context of this work, the previously discussed methods are therefore unsuitable or impractical. 
        As a result, two methods remain of primary relevance for achieving uncached memory accesses on the 
        target platform: cache eviction and cache flushing. These approaches are discussed in the following 
        subsections.
    
    \input{pa/cache-eviction}

    \input{pa/flush-cache}
