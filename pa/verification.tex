\subsection{Verification} \label{subsec:verification}
    A \gls{dram} mapping has been obtained for each test device. However, it remains uncertain whether 
    the reverse-engineered mapping is entirely correct (as seen in the 
    \hyperref[subsubsec:bank-function-derivation]{previous part}). Several methods can be employed 
    to verify the correctness of the derived \gls{dram} addressing functions.
    \\
    One approach is \textbf{physical probing}, which involves comparing the determined functions with results 
    obtained through direct hardware measurements, as described in [73]. This method, however, faces 
    significant practical limitations. Embedded systems often incorporate small chips and 
    multi-layered circuit boards [159], making direct probing difficult. In particular, verification 
    via hardware probing is not feasible on devices such as Raspberry Pi's due to the presence of 
    soldered \gls{dram} modules.
    \\
    Another verification method leverages \textbf{Rowhammer} testing. In this approach, correctness is 
    assessed by evaluating whether the use of the addressing functions in Rowhammer experiments 
    increases the number of bit flips per second proportionally to the number of sets identified [73]. 
    This method is often impractical because tests may require excessively long durations, the systems 
    under study may not be vulnerable, or mitigations may interfere with the results.
    \\
    The final method is a \textbf{software-based} verification, which entails performing timing measurements 
    across a larger set of addresses to detect differences consistent with the derived addressing 
    functions [73]. This approach is feasible and provides a practical means of validating the 
    correctness of the reverse-engineered \gls{dram} mappings.

    \subsubsection{Software-based} \label{subsubsec:software-based}
        Verification of \gls{dram} mapping is conducted using a software-based, latency-driven methodology, 
        following the approach proposed in the DRAMA methodology [73, 116]. This method's 
        Considerations are based on the cases that the system can encounter, specifically bank misses, row hits, 
        and row conflicts, as defined in the reverse engineering process. Each of these scenarios 
        exhibits distinct access latencies, which can be exploited to verify the underlying \gls{dram} mapping.
        \\
        The verification procedure involves several steps. First, it identifies memory addresses that 
        reside within the same or different \gls{dram} rows and banks, as shown in \hyperref[lst:find-related-addresses]{Listing~\ref{lst:find-related-addresses}}.
        Next, access latencies are measured after flushing the relevant cache lines to ensure that the 
        measurements reflect \gls{dram} behavior rather than cached values. The collected latency data are then organized 
        into histograms, which allow for the classification of row hits and row conflicts. These timing histograms 
        serve to calibrate a latency threshold, enabling the verification of the \gls{dram} mapping. Specifically, 
        addresses predicted to reside within the same row should exhibit low access latencies, while 
        addresses predicted to be located in different rows are expected to show higher latencies.
        \\
        This workflow faces challenges similar to those encountered in the previous 
        \hyperref[subsubsec:bank-function-derivation]{DRAMA-based reverse engineering process}. 
        Key difficulties include ensuring portability across ARM architectures and 
        mitigating measurement noise to maintain reliable latency distinctions.

        \input{listings/find-addresses.tex}

    \subsubsection{Rowhammer} \label{subsubsec:rowhammer}
        A secondary approach was tested to verify the \gls{dram} mapping using the Rowhammer technique. This 
        method aims to validate the addressing functions by observing whether their application leads 
        to an increased rate of bit flips in memory.
        \\
        % Workflow, Problems, and Solutions
        Memory allocation is performed via \texttt{mmap}, based on a predefined percentage of available system 
        memory, specified by \texttt{MEMORY\_IN\_PERCENT}. Virtual addresses are translated to physical 
        addresses using pagemap. Physical addresses that correspond to the 
        same \gls{dram} bank are grouped into lists according to a reverse-engineered \gls{dram} mapping.
        \\
        The hammering procedure iterates until a predefined number of cycles is reached, as denoted as
        \texttt{TIMES}. In each iteration, two physical addresses from the same bank are 
        selected randomly. These addresses are repeatedly accessed hammered for a defined number of 
        times while explicitly flushing the cache between accesses. After each 
        iteration, the system checks for resulting bit flips. Once the procedure completes, the total 
        number of detected bit flips is verified and reported.
        \\
        % Grouping Physical Addresses into DRAM Banks
        The grouping of physical addresses follows the goal of assigning physical addresses to \gls{dram} banks 
        according to the reverse-engineered mapping. These addresses are partitioned into bank-specific 
        lists, where each list contains addresses mapping to the same \gls{dram} bank. These lists form 
        the candidate sets used for the hammering process. The bank index is computed using the 
        algorithm shown in \hyperref[lst:compute_bank]{Listing~\ref{lst:compute_bank}}.
        \input{listings/compute_bank.tex}
        
        During the hammering phase, two addresses from the same bank are repeatedly accessed while 
        the cache is explicitly flushed after each access. This maximizes \gls{dram} row activations and is 
        intended to induce bit flips. The core idea is to randomly select two distinct addresses within 
        one bank and repeatedly toogle between both in sequence, flushing the cache lines after each access. This process 
        is repeated for a large number of cycles, as illustrated in 
        \hyperref[lst:hammer_mechanism]{Listing~\ref{lst:hammer_mechanism}}.
        \input{listings/hammer-mechanism.tex}
        
        % Related Work Mappings
        The tested mappings, including those from related work, were visually represented and compared 
        (see \hyperref[tab:mappings]{Table~\ref{tab:mappings}}).
        \begin{table}[ht]
            \centering
            \begin{tabular}{lll}
                \hline
                Device & Mappings & Bank Functions \\
                \hline
                Raspberry Pi 4B & Memory Aware DOS [74] & (11), (12), (13), (14) \\
                Raspberry Pi 4B & DRAM MaUT [79] & (12), (13), (14), (11 XOR 12) \\
                Raspberry Pi 3B+ & Flipping Bits Like a Pro [156] & (13 XOR 14), (14), (15) \\
                Exynos 7420 & DRAMA [73] & (14), (15), (16) \\
                Raspberry Pi's 4 & Rowhammer on Raspberry Pi's & (6), (12), (13), (14) \\
                Raspberry Pi's 5 & Rowhammer on Raspberry Pi's & (6), (12) \\
                \hline
            \end{tabular}
            \caption{Comparison between Related Work Mappings and own Thesis Mappings}
            \label{tab:mappings}
        \end{table}

        % Reverse-Engineered Mappings
        Multiple attacks were conducted to evaluate both the mappings proposed in related work and the 
        reverse-engineered mappings, with each Raspberry Pi device tested for approximately five hours.
        Across all tests, no bit flips were observed. The resulting mapping is likely correct, as it 
        closely resembles mappings reported in other studies for the Raspberry Pi 4 and older models. 
        Repeated measurements consistently produced the same mapping.
        \\
        The absence of bit flips indicates that either hardware or software mitigations effectively 
        prevent Rowhammer-induced errors, or the \gls{dram} modules under test are inherently resistant. 
        Therefore, based on the obtained results, no definitive conclusions regarding Rowhammer 
        susceptibility can be drawn for these devices.
