\section{Lab Setup} \label{sec:lab-setup}
  The laboratory setup was designed to establish a consistent and reproducible environment for both system 
  configuration and experimental execution, ensuring all devices, software, and development workflows were properly 
  prepared prior to conducting experiments.

  \subsection{System Setup} \label{sec:system-setup}
    % Github Setup
    The initial configuration of the laboratory environment involved setting up the necessary repositories for development 
    and documentation. A dedicated \textit{GitHub} repository was created for coding purposes on all 
    \hyperref[tab:experimental-setups]{test devices}, which contained the experimental programs, ported and adapted code, 
    and the main software required for running the experiments. In addition, separate repositories were established for 
    managing \textit{Obsidian} markdown files and \textit{LaTeX} documents related to the thesis work. The Obsidian repository 
    was used to maintain a glossary, track status updates, organize the table of contents, and store key points in a structured 
    manner. The \textit{LaTeX} repository served as the location for the fully elaborated final version of the thesis document.
    \\
    % Pi Setup
    For the Raspberry Pi systems, both public and private keys were generated for \textit{WireGuard} and \textit{\gls{ssh}} connections. 
    The corresponding public keys were transmitted to enable secure access on all devices. Functionality tests 
    were conducted to ensure all hosts and systems were operational. Direct access from the laptop to the Pi systems 
    was established by placing the authorized keys in the \texttt{.ssh/authorized\_keys} file on each device. All relevant IP 
    addresses were added to the \texttt{/etc/hosts} file on the laptop. \textit{Visual Studio Code} was configured with the 
    Remote \textit{\gls{ssh}} extension, alongside additional extensions for \textit{Python}, \textit{C}, and other required languages.
    \\
    % Unequal Versions of Header and Kernel
    Following the completion of system setup, multiple Raspberry Pi platforms with varying hardware configurations were 
    prepared for experimentation. Table~\ref{tab:experimental-setups} summarizes the experimental setups used in this 
    work, including the platform, processor architecture, \gls{soc}, and available \gls{dram}. All platforms were based on the ARMv8 architecture, 
    providing a common architectural baseline while differing in memory capacity and \gls{soc} generation.
    At the outset of the project, the test systems did not contain the data referenced in Table~\ref{tab:experimental-setups}, and the test 
    environments were based on different operating systems. In addition, software versions and system architectures 
    varied across the platforms, resulting in Raspberry Pi devices that were not aligned with each other. These 
    discrepancies affected the consistency of the experimental setup.
    On the Raspberry Pi 4 devices, older system installations were used. These systems ran Arch Linux ARM and reported 
    a CPU identified as an ARMv7 Processor revision 3 (v7l) on all Raspberry Pis 4. The kernel versions differed between 
    the devices, with version \texttt{6.12.25-1-rpi} on the 4 GB model and version \texttt{6.12.21-1-rpi} on the 8 GB model. 
    Kernel modules can be successfully run on Raspberry Pi 4 devices. However, the system architecture was armv7l. 
    In this configuration, user-mode execution lacks certain cache maintenance instructions, such as \texttt{dc civac}, \texttt{dc cvac}, 
    and \texttt{dc zva}. This limitation is inherent to the ARMv7-A architecture, where cache maintenance instructions are 
    restricted to privileged modes.
    The Raspberry Pi 5 devices also initially ran older system installations based on Arch Linux ARM. These systems 
    reported an ARMv8 Processor revision 1 (v8l) and used the aarch64 architecture. The kernel version installed was 
    \texttt{6.12.47.1-rpi-16k}. During initial testing, discrepancies were observed between the kernel and header versions on 
    the Raspberry Pi 5 systems. This mismatch led to complications when attempting to build and insert kernel modules. 
    Due to this incompatibility, kernel modules could not be fully compiled or loaded, as successful compilation 
    requires header files that exactly match the running kernel version.
    The objective at this stage was to align the kernel and header versions on the Raspberry Pi 5 systems. However, 
    a persistent version mismatch was encountered. After performing a full system upgrade using the command
    \texttt{pacman -Syu linux-rpi-16k linux-rpi-16k-headers}, the kernel was updated, but no corresponding newer header 
    package was available. As a result, the kernel and headers remained at different versions. Attempts to manually 
    downgrade the kernel were also unsuccessful. Installing a cached kernel package (\texttt{linux-rpi-16k-6.12.46-1}) via 
    \texttt{pacman -U} and rebooting did not result in the expected kernel version, even though the package was present on 
    the system. Other kernel versions could be installed successfully, but still without matching header versions. 
    Furthermore, a repository inconsistency was observed. Although the kernel appeared outdated on the systems, the 
    kernel and headers shared the same version in the repositories. This discrepancy may have been caused by mirrors 
    lagging behind the Arch Linux ARM website.
    After all attempted approaches failed, a final decision was made to align the systems by reinstalling all Raspberry 
    Pi devices. The reinstall was motivated by several factors. First, the inability to execute kernel modules reliably 
    hindered further experimentation. Second, the absence of cache flush instructions on ARMv7 systems prevented the 
    required cache management functionality. Reinstalling the systems would provide deterministic cache-line invalidation, 
    ensuring that every subsequent memory access is served from \gls{dram}, as discussed in more detail in the section on 
    uncached execution. Finally, a clean reinstallation reduced setup complexity by avoiding the need for eviction-set 
    construction and timing-based profiling, thereby establishing a consistent and reliable experimental environment 
    across all platforms.
    \\
    % Reinstall Systems [Requirements]
    The hardware required for this process included a Raspberry Pi, a desktop computer, network cables, USB-C cables, 
    Micro HDMI to HDMI adapters, a mouse, a keyboard, a laptop, and a micro SD card with an adapter. Software 
    requirements consisted of the Raspberry Imager [165] installed on the laptop and backups of the Raspberry Pi, including 
    programs, boot files, \texttt{.ssh/authorized\_keys}, \texttt{/etc/wireguard/wg0.conf}, and the \gls{motd} 
    configuration.
    \\
    % Reinstall Systems [Workflow]
    The installation workflow began by inserting the micro SD card into the laptop and launching the Raspberry Imager 
    program. The device model and desired operating system were selected, followed by the micro SD card. Configuration 
    settings were edited to specify the hostname, username, password, disable WiFi since all Raspberry Pis were 
    connected via \gls{lan}, set the timezone to Berlin, configure the keyboard layout to German, and enable \gls{ssh} with public 
    key authentication using the pre-existing \texttt{authorized\_keys} file. The micro SD card was then flashed and inserted 
    into the Raspberry Pi again, which was powered on for automatic boot. Connectivity was verified via ping commands from the 
    laptop.
    \\
    Subsequently, the Raspberry Pi was updated and upgraded using \texttt{sudo apt update} and \texttt{sudo apt upgrade}, followed by a 
    reboot. The root password was set, and the \gls{ssh} configuration for root access was restored from backup. \gls{ssh} access 
    from the laptop to both user and root accounts on the Pi was verified. The \gls{motd} was configured by emptying the 
    existing file, creating a new executable script, and inserting backup content. Differences in user and root shell 
    configurations were resolved by backing up \texttt{.bashrc} files, copying the user shell configuration to root, and sourcing 
    the new configuration.
    \\
    WireGuard installation and configuration were completed on the Raspberry Pi, enabling the \gls{vpn} service, verifying 
    its status, and ensuring connectivity from the laptop. Internet connectivity was enforced over HTTPS by modifying 
    the apt configuration and sources list files, followed by updating package information. Essential tools, including 
    \texttt{git}, \texttt{linux-perf}, \texttt{tmux}, and \texttt{i2c-tools}, were installed. The \textit{GitHub} repositories 
    were cloned, and \textit{Git} configuration was initialized with the appropriate username and email.
    \\
    % Requirements & Automated Setup
    For Python development, a virtual environment was created, and all additional dependencies were installed.
    \\
    % Outcome
    All newly deployed systems are based on Raspberry Pi OS Lite 64-bit running on the aarch64 architecture. The Raspberry 
    Pi 4 uses kernel version \texttt{6.12.47+rpt-rpi-v8}, while the Raspberry Pi 5 runs kernel version \texttt{6.12.47+rpt-rpi-2712}. As a 
    result of this setup, all test systems now operate on the same operating system, have access to all maintenance 
    instructions that are relevant in Section \hyperref[sec:flush-cache]{Uncached}, and are capable of executing kernel modules.
    This unified system configuration provides several additional advantages. It ensures improved comparability of 
    experimental results, as all Raspberry Pi devices run on an identical software stack.

  \subsection{Experiment Setup} \label{sec:experiment-setup}
    For long-term experiments, the \gls{tmux} tool was installed to address the challenge of maintaining continuous processes on the 
    Raspberry Pi systems while allowing the user to disconnect from the \gls{ssh} session. \gls{tmux} is a terminal multiplexer that enables 
    multiple terminal sessions to be created, accessed, and controlled independently within a single \gls{ssh} connection. New 
    sessions were initiated using \texttt{tmux new -s <session\_name>}, allowing experiments to be executed within an isolated session. 
    Detachment from a session, performed with \texttt{Ctrl+B} followed by \texttt{D}, permitted the experiment to continue running in the background 
    even if the \gls{ssh} connection was closed. Detached sessions could later be reattached using \texttt{tmux a -t <session\_name>}, and 
    sessions that were no longer needed could be terminated with \texttt{tmux kill-session -t <session\_name>}. This setup ensured reliable 
    and uninterrupted execution of long-duration experiments while maintaining full control over multiple concurrent tasks.
  
  \subsection{Automated Scripts} \label{sec:automated-scripts}
    Automated scripts were developed to streamline experiment management. The ping\_pis.sh script checked the reachability 
    of all HammerPi hosts and summarized the results. The \texttt{start\_pis.sh} script verified host connectivity, opened terminal 
    tabs for each reachable host, and initiated \gls{ssh} connections while keeping terminals open after session closure. 
    The \texttt{build\_session.sh} script required a \gls{tmux} session name as an argument, verified host connectivity, skipped hosts 
    with existing sessions, and created new \gls{tmux} sessions on reachable hosts. The \texttt{kill\_session.sh} script terminated 
    specified \gls{tmux} sessions across hosts, skipping any hosts without the target session. The \texttt{show\_session.sh} script listed 
    all \gls{tmux} sessions per reachable host, provided the total session count, and indicated if no sessions were found. Finally, 
    the \texttt{connect\_with\_session.sh} script attached \gls{ssh} connections to existing \gls{tmux} sessions on reachable hosts, opening a 
    new terminal tab for each host and skipping hosts without the specified session.